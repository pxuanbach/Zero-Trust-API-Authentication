# Capstone Project — Zero‑Trust API Authentication: Proxy with mTLS + Token‑Based Signatures

**Môn:** NT2205 - Cryptography

**Tiêu đề đề tài:** Zero‑Trust API Authentication — Xây dựng proxy sử dụng mTLS kết hợp token‑based signatures (PoP/DPoP/holder‑of‑key) cho môi trường API & Cloud

---

## 1. Tóm tắt đề tài (Project Synopsis)

Đề tài hướng dẫn thiết kế, triển khai và đánh giá một **Zero‑Trust API gateway/proxy** dùng kết hợp **mutual TLS (mTLS)** cho xác thực bên máy‑không‑người (machine‑to‑machine) và **token‑based proof‑of‑possession (PoP)** cho xác thực người‑dùng / mobile (token binding). Mục tiêu thực tế: bảo đảm tính xác thực, toàn vẹn và chống replay cho các cuộc gọi API trong môi trường cloud‑native, đồng thời cung cấp lộ trình vận hành (certificate lifecycle, key rotation, revocation) thích hợp cho production.

Đề tài bao gồm: phân tích threat model, thiết kế kiến trúc proxy (Envoy/Kong/NGINX/Istio), triển khai mTLS workflow, cài token PoP (ví dụ holder‑of‑key JWT / DPoP / MTLS‑bound tokens), xây dựng middleware ext\_authz để kiểm tra signature và cert‑binding, và thực hiện bench + test (latency, throughput, security tests). Sinh viên sẽ nộp repo reproducible (Docker/Helm), báo cáo và demo.

---

## 2. Mục tiêu học thuật & kỹ năng (Learning Objectives)

1. Hiểu rõ mô hình Zero‑Trust và cách mTLS + PoP tokens tăng cường bảo mật API.
2. Triển khai mTLS (client certs) kết hợp quản lý certificate (CA, cert‑manager, Vault) trong Kubernetes/Cloud.
3. Thiết kế & thực hiện PoP tokens: holder‑of‑key JWT (cnf claim), DPoP or HTTP Signatures pattern; bảo đảm binding giữa token và client key/certificate.
4. Tạo proxy/ext\_authz service (Envoy/Kong plugin hoặc custom Go/Node service) để thực thi policy: verify mTLS, verify token signature & binding, enforce scopes & replay protection.
5. Đánh giá hiệu năng và operational cost, đưa ra hướng dẫn rollout, key rotation và rollback.

---

## 3. Relevance & Motivation

* Zero‑Trust principle: không tin bất kỳ kết nối nào theo mặc định — mọi request đều phải được xác thực và ủy quyền.
* API Cloud là mặt phẳng tấn công quan trọng; bearer tokens dễ bị đánh cắp và sử dụng lại. mTLS cung cấp strong mutual auth cho machine clients, còn PoP tokens ràng buộc token với key của client (hoặc trình duyệt), giảm rủi ro token theft.
* Kết hợp hai cơ chế phù hợp cho hệ thống phân tán (microservices + external clients) cung cấp defense‑in‑depth.

---

## 4. Câu hỏi nghiên cứu & giả thuyết

**RQ1:** Kết hợp mTLS và token‑based PoP có giảm đáng kể nguy cơ token theft/replay so với chỉ dùng bearer JWT + TLS không?

**RQ2:** Overhead (latency, throughput) của việc kiểm tra mTLS + token binding ở proxy là bao nhiêu, và có thể tối ưu bằng caching/edge verification không?

**RQ3:** Chiến lược vận hành (CA, cert rotation, PKI automation) nào cân bằng tốt nhất giữa an toàn và vận hành đơn giản cho môi trường cloud?

**Giả thuyết:** Kịch bản hybrid (mTLS cho machine, PoP token cho user/mobile) sẽ giảm đáng kể replay/forgery vì attacker cần cả token và key/cert để giả mạo; với caching hợp lý và asynchronous introspection, overhead có thể được kiểm soát.

---

## 5. Background (Tổng quan ngắn)

* **mTLS:** mutual TLS — both client and server present X.509 certificates during TLS handshake; suitable for machine‑to‑machine authentication. Requires PKI: CA, issuance, revocation, rotation.
* **Bearer JWT vs PoP tokens:** Bearer tokens (simple) dễ bị lạm dụng nếu bị lộ. PoP tokens bind the token to a cryptographic key owned by the client — token useless without the key. Examples: holder‑of‑key JWT (cnf), DPoP (Demonstration of Proof-of-Possession), OAuth 2.0 mTLS (RFC 8705-style).
* **Proxy/Gateway choices:** Envoy (ext\_authz), Kong plugin, NGINX with lua, custom reverse proxy (Go/Node). Istio/SPIRE provide workload identity and automated mTLS in mesh.

---

## 6. Literature review & existing standards/tools (hướng khảo sát)

* RFCs & drafts: OAuth2 (RFC6749), OAuth mTLS (RFC8705), JWT (RFC7519), JWS (RFC7515), DPoP drafts / IETF discussions.
* Implementations & tools: Envoy ext\_authz, Istio mutual TLS, cert‑manager (Kubernetes), HashiCorp Vault PKI, Keycloak + OIDC PoP support.
* Best practice references: OWASP API Security, NIST guidelines for PKI key management.

> Yêu cầu: sinh viên trích dẫn ít nhất 6 nguồn/thư viện tiêu chuẩn và 3 project/repo (Envoy ext\_authz examples, cert‑manager, Vault PKI).

---

## 7. Methodology (Pipeline chi tiết)

### 7.1. Scope & use‑cases

* **Machine‑to‑Machine:** internal microservices, backend services use mTLS for mutual auth.
* **External Clients (mobile/browser):** use Authorization Code + PKCE (OIDC) to obtain PoP tokens bound to client key (mobile keystore or ephemeral key in browser).
* **Third‑party integrators / partners:** prefer mTLS or asymmetric PoP tokens (ECDSA) for stronger binding.

### 7.2. Architecture (gợi ý)

* **Edge Proxy / Gateway (Envoy/Kong):** terminates TLS, enforces mTLS if required for client, extracts client cert metadata (subject, cert thumbprint), forwards request to ext\_authz service for token validation & binding check.
* **ext\_authz service:** verifies JWT signature (JWS), checks `cnf` or DPoP binding against provided cert thumbprint or DPoP signature, checks scope & revocation, enforces replay protection (nonce/timestamp). Returns allow/deny with enriched headers for downstream service.
* **IdP / Token issuer:** Keycloak/Auth0/OIDC provider issues PoP tokens (with `cnf` claim or DPoP requirement) and publishes JWKS; supports token introspection endpoint.
* **PKI & Certificate Issuance:** cert‑manager + cert‑issuer backed by Vault or internal CA to automate client cert lifecycle.

### 7.3. Token binding patterns (options)

1. **mTLS‑bound tokens (OAuth mTLS):** token contains `cnf` with x5t#S256 thumbprint; server verifies presented client cert during TLS handshake.
2. **DPoP (Demonstration of PoP):** client creates a DPoP header (JWS) proving possession of a private key; token bound to DPoP key.
3. **Holder‑of‑Key JWT (HoK):** JWT with `cnf` containing JWK; verification includes signature of request using private key that matches `cnf` JWK.
4. **Signed HTTP Messages (HTTP Signatures):** canonicalize request, sign derived string, and proxy verifies signature + token binding.

### 7.4. Preprocessing & verification steps at proxy

* **mTLS verification:** TLS handshake ensures client cert validity (chain, not revoked, within validity period).
* **Token validation:** JWS signature verification (using JWKS from IdP), check `exp`, `nbf`, `aud`, `iss`.
* **Binding verification:** match `cnf` x5t to client cert thumbprint OR verify DPoP header JWS signed by key matching token's `cnf`.
* **Replay protection:** DPoP nonce, server‑maintained replay cache (short TTL); for mTLS, check ephemeral keys/short cert TTLs + OCSP stapling.
* **Policy enforcement:** scopes, roles, rate limits, IP restrictions.

---

## 8. Implementation & Experiment Setup

### 8.1. Choices & stack

* **Proxy:** Envoy (recommended) with ext\_authz (Go/Python service) or Kong with plugin. Envoy integrates well with Istio and cert management.
* **ext\_authz service:** implement in Go (recommended for performance) or Node/Python (faster prototyping). Responsibilities: JWKS cache, DPoP verification, cnf matching, replay cache, introspection fallback.
* **IdP:** Keycloak (self‑hosted) or Auth0 for token issuance with extensions for PoP/mTLS.
* **PKI:** cert‑manager (Kubernetes) + Vault PKI or an internal CA for client cert issuance; automate renewal and revocation.
* **Deployment:** Kubernetes cluster (minikube/k3s) for reproducible environment; provide Docker Compose for simpler runs.

### 8.2. Test & evaluation harness

* **Functional tests:** use curl/OpenSSL/HTTP clients to simulate: (a) valid mTLS client + valid PoP token, (b) valid token but missing binding, (c) stolen token replay, (d) expired cert, (e) revoked cert scenario.
* **Load tests:** wrk/wrk2 or locust to measure throughput and added latency of auth steps (JWT verify, DPoP verify, cert checks).
* **Security tests:** simulate token theft (replay), signature forgeries, MITM attempts against bearer tokens, algorithm downgrade attempts.
* **Operational tests:** cert rotation events, IdP JWKS rotation, network partitions between proxy and IdP (test cache fallback behavior).

### 8.3. Metrics to collect

* Latency added by ext\_authz (median, p95, p99), total request latency at gateway.
* Throughput (requests/sec) under different loads.
* CPU & memory utilization of ext\_authz and proxy.
* Replay cache size & hit/miss ratios.
* Failure modes: authentication error rates under scenarios.

---

## 9. Evaluation Plan & Metrics

* **Security efficacy:** reduction in successful replay/forgery incidents in testbed; ability to detect token misuse tied to missing binding.
* **Performance:** auth latency (median & tail), throughput impact vs baseline (TLS only + bearer tokens).
* **Operational resilience:** impact of cert rotation & JWKS rotation on availability; success of automatic recovery strategies.
* **Developer ergonomics & compatibility:** complexity to onboard new clients, SDKs required, steps for mobile vs browser vs machine clients.

---

## 10. Timeline & Milestones (12 tuần)

* **Tuần 1–2:** Survey (OAuth mTLS, DPoP, holder‑of‑key patterns), choose stack (Envoy + Keycloak), setup k8s dev cluster.
* **Tuần 3–4:** Implement PKI provisioner (cert‑manager + Vault), automate client cert issuance for test clients.
* **Tuần 5–6:** Implement ext\_authz prototype: JWKS cache, JWS verify, cnf/mTLS thumbprint matching.
* **Tuần 7–8:** Add DPoP/HoK verification, implement replay cache and nonce handling.
* **Tuần 9:** Integrate with Envoy/Kong and deploy sample microservices; functional testing.
* **Tuần 10:** Load testing & performance tuning (caching, concurrency).
* **Tuần 11:** Operational scenarios (rotation, failure recovery), finalize experiments.
* **Tuần 12:** Finalize report, code cleanup, demo & presentation.

---

## 11. Deliverables

1. **Mid‑term:** architecture diagram, pipeline spec, initial ext\_authz prototype.
2. **Final report & repo:** reproducible Docker/Helm charts, ext\_authz source, Envoy/Kong configs, test scripts, and experimental results (CSV + plots).
3. **Demo:** recorded live demo showing mTLS + PoP successful auth and attack scenarios blocked.
4. **Operational runbook:** how to issue/rotate/revoke certs, JWKS rotation handling, rollback plan.

---

## 12. Assessment & Rubric (gợi ý)

* Concept & design (Zero‑Trust reasoning): 25%
* Implementation & reproducibility (code + infra): 25%
* Security experiments & rigour: 25%
* Performance & operational analysis: 15%
* Report & presentation: 10%

---

## 13. Risks, Limitations & Mitigation

* **Complexity of client support (mobile/browser):** browsers may not expose private key hardware; use DPoP or platform keystore APIs.
* **PKI management burden:** automate with cert‑manager + Vault; keep short cert lifetimes and robust revocation/health checks.
* **Replay cache stateful cost:** keep TTL small and scale cache using distributed store (Redis) with eviction policies.
* **Backward compatibility:** support fallback to bearer tokens with strict monitoring and canary rollout.

---

## 14. Ethics & Responsible Use

* Use only test accounts/keys; do not expose production credentials.
* If any library vulnerability discovered, follow responsible disclosure.
* Avoid logging sensitive token parts or private cert material; redact PII.

---

## 15. Extensions & Future Work

* Integrate with SPIFFE/SPIRE for workload identity across multi‑cluster.
* Support attestation‑based tokens (TEE attestation) for stronger device binding.
* Combine with anomaly detection (ML) to flag unusual token usage or binding failures.

---

## 16. Tools & Resources gợi ý

* Envoy + ext\_authz, Kong, NGINX (lua), Istio, cert‑manager, HashiCorp Vault, Keycloak/Auth0.
* Libraries: pyjwt/node‑jose/jose4j, Go jose/jwt libs, OpenSSL CLI.
* Load testing & monitoring: wrk2, locust, Prometheus, Grafana, OpenTelemetry.
